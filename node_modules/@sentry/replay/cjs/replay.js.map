{"version":3,"file":"replay.js","sources":["../../../src/replay.ts"],"sourcesContent":["/* eslint-disable max-lines */ // TODO: We might want to split this file up\nimport { addGlobalEventProcessor, captureException, getCurrentHub } from '@sentry/core';\nimport type { Breadcrumb, ReplayRecordingMode } from '@sentry/types';\nimport type { RateLimits } from '@sentry/utils';\nimport { addInstrumentationHandler, disabledUntil, logger } from '@sentry/utils';\nimport { EventType, record } from 'rrweb';\n\nimport { MAX_SESSION_LIFE, SESSION_IDLE_DURATION, VISIBILITY_CHANGE_TIMEOUT, WINDOW } from './constants';\nimport { breadcrumbHandler } from './coreHandlers/breadcrumbHandler';\nimport { handleFetchSpanListener } from './coreHandlers/handleFetch';\nimport { handleGlobalEventListener } from './coreHandlers/handleGlobalEvent';\nimport { handleHistorySpanListener } from './coreHandlers/handleHistory';\nimport { handleXhrSpanListener } from './coreHandlers/handleXhr';\nimport { setupPerformanceObserver } from './coreHandlers/performanceObserver';\nimport { createEventBuffer } from './eventBuffer';\nimport { getSession } from './session/getSession';\nimport { saveSession } from './session/saveSession';\nimport type {\n  AddEventResult,\n  AddUpdateCallback,\n  AllPerformanceEntry,\n  EventBuffer,\n  InstrumentationTypeBreadcrumb,\n  InternalEventContext,\n  PopEventContext,\n  RecordingEvent,\n  RecordingOptions,\n  ReplayContainer as ReplayContainerInterface,\n  ReplayPluginOptions,\n  Session,\n} from './types';\nimport { addEvent } from './util/addEvent';\nimport { addMemoryEntry } from './util/addMemoryEntry';\nimport { createBreadcrumb } from './util/createBreadcrumb';\nimport { createPerformanceEntries } from './util/createPerformanceEntries';\nimport { createPerformanceSpans } from './util/createPerformanceSpans';\nimport { debounce } from './util/debounce';\nimport { isExpired } from './util/isExpired';\nimport { isSessionExpired } from './util/isSessionExpired';\nimport { overwriteRecordDroppedEvent, restoreRecordDroppedEvent } from './util/monkeyPatchRecordDroppedEvent';\nimport { sendReplay } from './util/sendReplay';\nimport { RateLimitError } from './util/sendReplayRequest';\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nexport class ReplayContainer implements ReplayContainerInterface {\n  public eventBuffer: EventBuffer | null = null;\n\n  /**\n   * List of PerformanceEntry from PerformanceObserver\n   */\n  public performanceEvents: AllPerformanceEntry[] = [];\n\n  public session: Session | undefined;\n\n  /**\n   * Recording can happen in one of two modes:\n   * * session: Record the whole session, sending it continuously\n   * * error: Always keep the last 60s of recording, and when an error occurs, send it immediately\n   */\n  public recordingMode: ReplayRecordingMode = 'session';\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n  private readonly _recordingOptions: RecordingOptions;\n\n  private readonly _options: ReplayPluginOptions;\n\n  private _performanceObserver: PerformanceObserver | null = null;\n\n  private _debouncedFlush: ReturnType<typeof debounce>;\n  private _flushLock: Promise<unknown> | null = null;\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n  private _lastActivity: number = new Date().getTime();\n\n  /**\n   * Is the integration currently active?\n   */\n  private _isEnabled: boolean = false;\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n  private _isPaused: boolean = false;\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n  private _hasInitializedCoreListeners: boolean = false;\n\n  /**\n   * Function to stop recording\n   */\n  private _stopRecording: ReturnType<typeof record> | null = null;\n\n  private _context: InternalEventContext = {\n    errorIds: new Set(),\n    traceIds: new Set(),\n    urls: [],\n    earliestEvent: null,\n    initialTimestamp: new Date().getTime(),\n    initialUrl: '',\n  };\n\n  public constructor({\n    options,\n    recordingOptions,\n  }: {\n    options: ReplayPluginOptions;\n    recordingOptions: RecordingOptions;\n  }) {\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay,\n    });\n  }\n\n  /** Get the event context. */\n  public getContext(): InternalEventContext {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n  public isEnabled(): boolean {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n  public isPaused(): boolean {\n    return this._isPaused;\n  }\n\n  /** Get the replay integration options. */\n  public getOptions(): ReplayPluginOptions {\n    return this._options;\n  }\n\n  /**\n   * Initializes the plugin.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n  public start(): void {\n    this._setInitialState();\n\n    this._loadSession({ expiry: SESSION_IDLE_DURATION });\n\n    // If there is no session, then something bad has happened - can't continue\n    if (!this.session) {\n      this._handleException(new Error('No session found'));\n      return;\n    }\n\n    if (!this.session.sampled) {\n      // If session was not sampled, then we do not initialize the integration at all.\n      return;\n    }\n\n    // If session is sampled for errors, then we need to set the recordingMode\n    // to 'error', which will configure recording with different options.\n    if (this.session.sampled === 'error') {\n      this.recordingMode = 'error';\n    }\n\n    // setup() is generally called on page load or manually - in both cases we\n    // should treat it as an activity\n    this._updateSessionActivity();\n\n    this.eventBuffer = createEventBuffer({\n      useCompression: Boolean(this._options.useCompression),\n    });\n\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n\n    this.startRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n  public startRecording(): void {\n    try {\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don't want\n        // instead, we'll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === 'error' && { checkoutEveryNms: 60000 }),\n        emit: this._handleRecordingEmit,\n      });\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   * Returns true if it was stopped, else false.\n   */\n  public stopRecording(): boolean {\n    if (this._stopRecording) {\n      this._stopRecording();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n  public stop(): void {\n    try {\n      __DEBUG_BUILD__ && logger.log('[Replay] Stopping Replays');\n      this._isEnabled = false;\n      this._removeListeners();\n      this._stopRecording && this._stopRecording();\n      this.eventBuffer && this.eventBuffer.destroy();\n      this.eventBuffer = null;\n      this._debouncedFlush.cancel();\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n  public pause(): void {\n    this._isPaused = true;\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n  public resume(): void {\n    this._isPaused = false;\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n  public addUpdate(cb: AddUpdateCallback): void {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == 'error'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === 'error') {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being \"active\" (e.g. a mouse click).\n   */\n  public triggerUserActivity(): void {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      this._loadSession({ expiry: SESSION_IDLE_DURATION });\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this._checkAndHandleExpiredSession();\n\n    this._updateSessionActivity();\n  }\n\n  /**\n   *\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of mulitple flushes happening closely together.\n   */\n  public flushImmediate(): Promise<void> {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush() as Promise<void>;\n  }\n\n  /** Get the current sesion (=replay) ID */\n  public getSessionId(): string | undefined {\n    return this.session && this.session.id;\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n  private _handleException(error: unknown): void {\n    __DEBUG_BUILD__ && logger.error('[Replay]', error);\n\n    if (__DEBUG_BUILD__ && this._options._experiments && this._options._experiments.captureExceptions) {\n      captureException(error);\n    }\n  }\n\n  /**\n   * Loads a session from storage, or creates a new one if it does not exist or\n   * is expired.\n   */\n  private _loadSession({ expiry }: { expiry: number }): void {\n    const { type, session } = getSession({\n      expiry,\n      stickySession: Boolean(this._options.stickySession),\n      currentSession: this.session,\n      sessionSampleRate: this._options.sessionSampleRate,\n      errorSampleRate: this._options.errorSampleRate,\n    });\n\n    // If session was newly created (i.e. was not loaded from storage), then\n    // enable flag to create the root replay\n    if (type === 'new') {\n      this._setInitialState();\n    }\n\n    const currentSessionId = this.getSessionId();\n    if (session.id !== currentSessionId) {\n      session.previousSessionId = currentSessionId;\n    }\n\n    this.session = session;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n  private _setInitialState(): void {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n\n    this.performanceEvents = [];\n\n    // Reset _context as well\n    this._clearContext();\n\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = new Date().getTime();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n  private _addListeners(): void {\n    try {\n      WINDOW.document.addEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.addEventListener('blur', this._handleWindowBlur);\n      WINDOW.addEventListener('focus', this._handleWindowFocus);\n\n      // We need to filter out dropped events captured by `addGlobalEventProcessor(this.handleGlobalEvent)` below\n      overwriteRecordDroppedEvent(this._context.errorIds);\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        // Listeners from core SDK //\n        const scope = getCurrentHub().getScope();\n        if (scope) {\n          scope.addScopeListener(this._handleCoreBreadcrumbListener('scope'));\n        }\n        addInstrumentationHandler('dom', this._handleCoreBreadcrumbListener('dom'));\n        addInstrumentationHandler('fetch', handleFetchSpanListener(this));\n        addInstrumentationHandler('xhr', handleXhrSpanListener(this));\n        addInstrumentationHandler('history', handleHistorySpanListener(this));\n\n        // Tag all (non replay) events that get sent to Sentry with the current\n        // replay ID so that we can reference them later in the UI\n        addGlobalEventProcessor(handleGlobalEventListener(this));\n\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this._handleException(err);\n    }\n\n    // _performanceObserver //\n    if (!('_performanceObserver' in WINDOW)) {\n      return;\n    }\n\n    this._performanceObserver = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n  private _removeListeners(): void {\n    try {\n      WINDOW.document.removeEventListener('visibilitychange', this._handleVisibilityChange);\n\n      WINDOW.removeEventListener('blur', this._handleWindowBlur);\n      WINDOW.removeEventListener('focus', this._handleWindowFocus);\n\n      restoreRecordDroppedEvent();\n\n      if (this._performanceObserver) {\n        this._performanceObserver.disconnect();\n        this._performanceObserver = null;\n      }\n    } catch (err) {\n      this._handleException(err);\n    }\n  }\n\n  /**\n   * Handler for recording events.\n   *\n   * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n   */\n  private _handleRecordingEmit: (event: RecordingEvent, isCheckout?: boolean) => void = (\n    event: RecordingEvent,\n    isCheckout?: boolean,\n  ) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!this._checkAndHandleExpiredSession()) {\n      __DEBUG_BUILD__ && logger.error('[Replay] Received replay event after session expired.');\n\n      return;\n    }\n\n    this.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (this.recordingMode === 'error' && event.type === 2) {\n        this._setInitialState();\n      }\n\n      // We need to clear existing events on a checkout, otherwise they are\n      // incremental event updates and should be appended\n      void addEvent(this, event, isCheckout);\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (event.type !== 2) {\n        return false;\n      }\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (this.session && this.session.previousSessionId) {\n        return true;\n      }\n\n      // See note above re: session start needs to reflect the most recent\n      // checkout.\n      if (this.recordingMode === 'error' && this.session && this._context.earliestEvent) {\n        this.session.started = this._context.earliestEvent;\n        this._maybeSaveSession();\n      }\n\n      // Flush immediately so that we do not miss the first segment, otherwise\n      // it can prevent loading on the UI. This will cause an increase in short\n      // replays (e.g. opening and closing a tab quickly), but these can be\n      // filtered on the UI.\n      if (this.recordingMode === 'session') {\n        void this.flushImmediate();\n      }\n\n      return true;\n    });\n  };\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n  private _handleVisibilityChange: () => void = () => {\n    if (WINDOW.document.visibilityState === 'visible') {\n      this._doChangeToForegroundTasks();\n    } else {\n      this._doChangeToBackgroundTasks();\n    }\n  };\n\n  /**\n   * Handle when page is blurred\n   */\n  private _handleWindowBlur: () => void = () => {\n    const breadcrumb = createBreadcrumb({\n      category: 'ui.blur',\n    });\n\n    // Do not count blur as a user action -- it's part of the process of them\n    // leaving the page\n    this._doChangeToBackgroundTasks(breadcrumb);\n  };\n\n  /**\n   * Handle when page is focused\n   */\n  private _handleWindowFocus: () => void = () => {\n    const breadcrumb = createBreadcrumb({\n      category: 'ui.focus',\n    });\n\n    // Do not count focus as a user action -- instead wait until they focus and\n    // interactive with page\n    this._doChangeToForegroundTasks(breadcrumb);\n  };\n\n  /**\n   * Handler for Sentry Core SDK events.\n   *\n   * These events will create breadcrumb-like objects in the recording.\n   */\n  private _handleCoreBreadcrumbListener: (type: InstrumentationTypeBreadcrumb) => (handlerData: unknown) => void =\n    (type: InstrumentationTypeBreadcrumb) =>\n    (handlerData: unknown): void => {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      const result = breadcrumbHandler(type, handlerData);\n\n      if (result === null) {\n        return;\n      }\n\n      if (result.category === 'sentry.transaction') {\n        return;\n      }\n\n      if (result.category === 'ui.click') {\n        this.triggerUserActivity();\n      } else {\n        this._checkAndHandleExpiredSession();\n      }\n\n      this.addUpdate(() => {\n        void addEvent(this, {\n          type: EventType.Custom,\n          // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n          // but maybe we should just keep them as milliseconds\n          timestamp: (result.timestamp || 0) * 1000,\n          data: {\n            tag: 'breadcrumb',\n            payload: result,\n          },\n        });\n\n        // Do not flush after console log messages\n        return result.category === 'console';\n      });\n    };\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n  private _doChangeToBackgroundTasks(breadcrumb?: Breadcrumb): void {\n    if (!this.session) {\n      return;\n    }\n\n    const expired = isSessionExpired(this.session, VISIBILITY_CHANGE_TIMEOUT);\n\n    if (breadcrumb && !expired) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    this._conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n  private _doChangeToForegroundTasks(breadcrumb?: Breadcrumb): void {\n    if (!this.session) {\n      return;\n    }\n\n    const isSessionActive = this._checkAndHandleExpiredSession({\n      expiry: VISIBILITY_CHANGE_TIMEOUT,\n    });\n\n    if (!isSessionActive) {\n      // If the user has come back to the page within VISIBILITY_CHANGE_TIMEOUT\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      __DEBUG_BUILD__ && logger.log('[Replay] Document has become active, but session has expired');\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Trigger rrweb to take a full snapshot which will cause this plugin to\n   * create a new Replay event.\n   */\n  private _triggerFullSnapshot(): void {\n    __DEBUG_BUILD__ && logger.log('[Replay] Taking full rrweb snapshot');\n    record.takeFullSnapshot(true);\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n  private _updateUserActivity(_lastActivity: number = new Date().getTime()): void {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session's last activity timestamp\n   */\n  private _updateSessionActivity(_lastActivity: number = new Date().getTime()): void {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n  private _createCustomBreadcrumb(breadcrumb: Breadcrumb): void {\n    this.addUpdate(() => {\n      void addEvent(this, {\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: 'breadcrumb',\n          payload: breadcrumb,\n        },\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEvents`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n  private _addPerformanceEntries(): Promise<Array<AddEventResult | null>> {\n    // Copy and reset entries before processing\n    const entries = [...this.performanceEvents];\n    this.performanceEvents = [];\n\n    return Promise.all(createPerformanceSpans(this, createPerformanceEntries(entries)));\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   */\n  private _checkAndHandleExpiredSession({ expiry = SESSION_IDLE_DURATION }: { expiry?: number } = {}): boolean | void {\n    const oldSessionId = this.getSessionId();\n\n    // Prevent starting a new session if the last user activity is older than\n    // MAX_SESSION_LIFE. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (this._lastActivity && isExpired(this._lastActivity, MAX_SESSION_LIFE)) {\n      // Pause recording\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    this._loadSession({ expiry });\n\n    // Session was expired if session ids do not match\n    const expired = oldSessionId !== this.getSessionId();\n\n    if (!expired) {\n      return true;\n    }\n\n    // Session is expired, trigger a full snapshot (which will create a new session)\n    this._triggerFullSnapshot();\n\n    return false;\n  }\n\n  /**\n   * Only flush if `this.recordingMode === 'session'`\n   */\n  private _conditionalFlush(): void {\n    if (this.recordingMode === 'error') {\n      return;\n    }\n\n    void this.flushImmediate();\n  }\n\n  /**\n   * Clear _context\n   */\n  private _clearContext(): void {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n    this._context.earliestEvent = null;\n  }\n\n  /**\n   * Return and clear _context\n   */\n  private _popEventContext(): PopEventContext {\n    if (this._context.earliestEvent && this._context.earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = this._context.earliestEvent;\n    }\n\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds).filter(Boolean),\n      traceIds: Array.from(this._context.traceIds).filter(Boolean),\n      urls: this._context.urls,\n    };\n\n    this._clearContext();\n\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n  private async _runFlush(): Promise<void> {\n    if (!this.session || !this.eventBuffer) {\n      __DEBUG_BUILD__ && logger.error('[Replay] No session or eventBuffer found to flush.');\n      return;\n    }\n\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer || !this.eventBuffer.pendingLength) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    try {\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n\n      // NOTE: Copy values from instance members, as it's possible they could\n      // change before the flush finishes.\n      const replayId = this.session.id;\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        includeReplayStartTimestamp: segmentId === 0,\n        eventContext,\n        session: this.session,\n        options: this.getOptions(),\n        timestamp: new Date().getTime(),\n      });\n    } catch (err) {\n      this._handleException(err);\n\n      if (err instanceof RateLimitError) {\n        this._handleRateLimit(err.rateLimits);\n        return;\n      }\n\n      // This means we retried 3 times, and all of them failed\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      this.stop();\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n  private _flush: () => Promise<void> = async () => {\n    if (!this._isEnabled) {\n      // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n      return;\n    }\n\n    if (!this._checkAndHandleExpiredSession()) {\n      __DEBUG_BUILD__ && logger.error('[Replay] Attempting to finish replay event after session expired.');\n      return;\n    }\n\n    if (!this.session) {\n      __DEBUG_BUILD__ && logger.error('[Replay] No session found to flush.');\n      return;\n    }\n\n    // A flush is about to happen, cancel any queued flushes\n    this._debouncedFlush.cancel();\n\n    // this._flushLock acts as a lock so that future calls to `_flush()`\n    // will be blocked until this promise resolves\n    if (!this._flushLock) {\n      this._flushLock = this._runFlush();\n      await this._flushLock;\n      this._flushLock = null;\n      return;\n    }\n\n    // Wait for previous flush to finish, then call the debounced `_flush()`.\n    // It's possible there are other flush requests queued and waiting for it\n    // to resolve. We want to reduce all outstanding requests (as well as any\n    // new flush requests that occur within a second of the locked flush\n    // completing) into a single flush.\n\n    try {\n      await this._flushLock;\n    } catch (err) {\n      __DEBUG_BUILD__ && logger.error(err);\n    } finally {\n      this._debouncedFlush();\n    }\n  };\n\n  /** Save the session, if it is sticky */\n  private _maybeSaveSession(): void {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /**\n   * Pauses the replay and resumes it after the rate-limit duration is over.\n   */\n  private _handleRateLimit(rateLimits: RateLimits): void {\n    // in case recording is already paused, we don't need to do anything, as we might have already paused because of a\n    // rate limit\n    if (this.isPaused()) {\n      return;\n    }\n\n    const rateLimitEnd = disabledUntil(rateLimits, 'replay');\n    const rateLimitDuration = rateLimitEnd - Date.now();\n\n    if (rateLimitDuration > 0) {\n      __DEBUG_BUILD__ && logger.warn('[Replay]', `Rate limit hit, pausing replay for ${rateLimitDuration}ms`);\n      this.pause();\n      this._debouncedFlush.cancel();\n\n      setTimeout(() => {\n        __DEBUG_BUILD__ && logger.info('[Replay]', 'Resuming replay after rate limit');\n        this.resume();\n      }, rateLimitDuration);\n    }\n  }\n}\n"],"names":["debounce","SESSION_IDLE_DURATION","createEventBuffer","record","logger","captureException","getSession","WINDOW","overwriteRecordDroppedEvent","getCurrentHub","addInstrumentationHandler","handleFetchSpanListener","handleXhrSpanListener","handleHistorySpanListener","addGlobalEventProcessor","handleGlobalEventListener","setupPerformanceObserver","restoreRecordDroppedEvent","addEvent","createBreadcrumb","breadcrumbHandler","EventType","isSessionExpired","VISIBILITY_CHANGE_TIMEOUT","createPerformanceSpans","createPerformanceEntries","isExpired","MAX_SESSION_LIFE","addMemoryEntry","sendReplay","RateLimitError","saveSession","disabledUntil"],"mappings":"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"}