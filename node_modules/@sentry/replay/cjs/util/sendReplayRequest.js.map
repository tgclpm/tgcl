{"version":3,"file":"sendReplayRequest.js","sources":["../../../../src/util/sendReplayRequest.ts"],"sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport type { ReplayEvent, TransportMakeRequestResponse } from '@sentry/types';\nimport type { RateLimits } from '@sentry/utils';\nimport { isRateLimited, logger, updateRateLimits } from '@sentry/utils';\n\nimport { REPLAY_EVENT_NAME, UNABLE_TO_SEND_REPLAY } from '../constants';\nimport type { SendReplayData } from '../types';\nimport { createReplayEnvelope } from './createReplayEnvelope';\nimport { prepareRecordingData } from './prepareRecordingData';\nimport { prepareReplayEvent } from './prepareReplayEvent';\n\n/**\n * Send replay attachment using `fetch()`\n */\nexport async function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  includeReplayStartTimestamp,\n  eventContext,\n  timestamp,\n  session,\n  options,\n}: SendReplayData): Promise<void | TransportMakeRequestResponse> {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id,\n    },\n  });\n\n  const { urls, errorIds, traceIds, initialTimestamp } = eventContext;\n\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n  const scope = hub.getScope();\n  const transport = client && client.getTransport();\n  const dsn = client && client.getDsn();\n\n  if (!client || !scope || !transport || !dsn || !session.sampled) {\n    return;\n  }\n\n  const baseEvent: ReplayEvent = {\n    // @ts-ignore private api\n    type: REPLAY_EVENT_NAME,\n    ...(includeReplayStartTimestamp ? { replay_start_timestamp: initialTimestamp / 1000 } : {}),\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled,\n  };\n\n  const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });\n\n  if (!replayEvent) {\n    // Taken from baseclient's `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent('event_processor', 'replay_event', baseEvent);\n    __DEBUG_BUILD__ && logger.log('An event processor returned `null`, will not send event.');\n    return;\n  }\n\n  replayEvent.tags = {\n    ...replayEvent.tags,\n    sessionSampleRate: options.sessionSampleRate,\n    errorSampleRate: options.errorSampleRate,\n  };\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      \"type\": \"replay_event\",\n      \"timestamp\": 1670837008.634,\n      \"error_ids\": [\n          \"errorId\"\n      ],\n      \"trace_ids\": [\n          \"traceId\"\n      ],\n      \"urls\": [\n          \"https://example.com\"\n      ],\n      \"replay_id\": \"eventId\",\n      \"segment_id\": 3,\n      \"replay_type\": \"error\",\n      \"platform\": \"javascript\",\n      \"event_id\": \"eventId\",\n      \"environment\": \"production\",\n      \"sdk\": {\n          \"integrations\": [\n              \"BrowserTracing\",\n              \"Replay\"\n          ],\n          \"name\": \"sentry.javascript.browser\",\n          \"version\": \"7.25.0\"\n      },\n      \"sdkProcessingMetadata\": {},\n      \"tags\": {\n          \"sessionSampleRate\": 1,\n          \"errorSampleRate\": 0,\n      }\n  }\n  */\n\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n\n  let response: void | TransportMakeRequestResponse;\n\n  try {\n    response = await transport.send(envelope);\n  } catch {\n    throw new Error(UNABLE_TO_SEND_REPLAY);\n  }\n\n  // TODO (v8): we can remove this guard once transport.send's type signature doesn't include void anymore\n  if (!response) {\n    return response;\n  }\n\n  const rateLimits = updateRateLimits({}, response);\n  if (isRateLimited(rateLimits, 'replay')) {\n    throw new RateLimitError(rateLimits);\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === 'number' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n\n  return response;\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nexport class RateLimitError extends Error {\n  public rateLimits: RateLimits;\n\n  public constructor(rateLimits: RateLimits) {\n    super('Rate limit hit');\n    this.rateLimits = rateLimits;\n  }\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nexport class TransportStatusCodeError extends Error {\n  public constructor(statusCode: number) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n"],"names":["prepareRecordingData","getCurrentHub","REPLAY_EVENT_NAME","prepareReplayEvent","logger","createReplayEnvelope","UNABLE_TO_SEND_REPLAY","updateRateLimits","isRateLimited"],"mappings":";;;;;;;;;AAWA;AACA;AACA;AACA,eAAA,iBAAA,CAAA;AACA,EAAA,aAAA;AACA,EAAA,QAAA;AACA,EAAA,SAAA,EAAA,UAAA;AACA,EAAA,2BAAA;AACA,EAAA,YAAA;AACA,EAAA,SAAA;AACA,EAAA,OAAA;AACA,EAAA,OAAA;AACA,CAAA,EAAA;AACA,EAAA,MAAA,qBAAA,GAAAA,yCAAA,CAAA;AACA,IAAA,aAAA;AACA,IAAA,OAAA,EAAA;AACA,MAAA,UAAA;AACA,KAAA;AACA,GAAA,CAAA,CAAA;AACA;AACA,EAAA,MAAA,EAAA,IAAA,EAAA,QAAA,EAAA,QAAA,EAAA,gBAAA,EAAA,GAAA,YAAA,CAAA;AACA;AACA,EAAA,MAAA,GAAA,GAAAC,kBAAA,EAAA,CAAA;AACA,EAAA,MAAA,MAAA,GAAA,GAAA,CAAA,SAAA,EAAA,CAAA;AACA,EAAA,MAAA,KAAA,GAAA,GAAA,CAAA,QAAA,EAAA,CAAA;AACA,EAAA,MAAA,SAAA,GAAA,MAAA,IAAA,MAAA,CAAA,YAAA,EAAA,CAAA;AACA,EAAA,MAAA,GAAA,GAAA,MAAA,IAAA,MAAA,CAAA,MAAA,EAAA,CAAA;AACA;AACA,EAAA,IAAA,CAAA,MAAA,IAAA,CAAA,KAAA,IAAA,CAAA,SAAA,IAAA,CAAA,GAAA,IAAA,CAAA,OAAA,CAAA,OAAA,EAAA;AACA,IAAA,OAAA;AACA,GAAA;AACA;AACA,EAAA,MAAA,SAAA,GAAA;AACA;AACA,IAAA,IAAA,EAAAC,2BAAA;AACA,IAAA,IAAA,2BAAA,GAAA,EAAA,sBAAA,EAAA,gBAAA,GAAA,IAAA,EAAA,GAAA,EAAA,CAAA;AACA,IAAA,SAAA,EAAA,SAAA,GAAA,IAAA;AACA,IAAA,SAAA,EAAA,QAAA;AACA,IAAA,SAAA,EAAA,QAAA;AACA,IAAA,IAAA;AACA,IAAA,SAAA,EAAA,QAAA;AACA,IAAA,UAAA;AACA,IAAA,WAAA,EAAA,OAAA,CAAA,OAAA;AACA,GAAA,CAAA;AACA;AACA,EAAA,MAAA,WAAA,GAAA,MAAAC,qCAAA,CAAA,EAAA,KAAA,EAAA,MAAA,EAAA,QAAA,EAAA,KAAA,EAAA,SAAA,EAAA,CAAA,CAAA;AACA;AACA,EAAA,IAAA,CAAA,WAAA,EAAA;AACA;AACA,IAAA,MAAA,CAAA,kBAAA,CAAA,iBAAA,EAAA,cAAA,EAAA,SAAA,CAAA,CAAA;AACA,IAAA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAAC,YAAA,CAAA,GAAA,CAAA,0DAAA,CAAA,CAAA;AACA,IAAA,OAAA;AACA,GAAA;AACA;AACA,EAAA,WAAA,CAAA,IAAA,GAAA;AACA,IAAA,GAAA,WAAA,CAAA,IAAA;AACA,IAAA,iBAAA,EAAA,OAAA,CAAA,iBAAA;AACA,IAAA,eAAA,EAAA,OAAA,CAAA,eAAA;AACA,GAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAA,MAAA,QAAA,GAAAC,yCAAA,CAAA,WAAA,EAAA,qBAAA,EAAA,GAAA,EAAA,MAAA,CAAA,UAAA,EAAA,CAAA,MAAA,CAAA,CAAA;AACA;AACA,EAAA,IAAA,QAAA,CAAA;AACA;AACA,EAAA,IAAA;AACA,IAAA,QAAA,GAAA,MAAA,SAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA;AACA,GAAA,CAAA,OAAA,CAAA,EAAA;AACA,IAAA,MAAA,IAAA,KAAA,CAAAC,+BAAA,CAAA,CAAA;AACA,GAAA;AACA;AACA;AACA,EAAA,IAAA,CAAA,QAAA,EAAA;AACA,IAAA,OAAA,QAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,MAAA,UAAA,GAAAC,sBAAA,CAAA,EAAA,EAAA,QAAA,CAAA,CAAA;AACA,EAAA,IAAAC,mBAAA,CAAA,UAAA,EAAA,QAAA,CAAA,EAAA;AACA,IAAA,MAAA,IAAA,cAAA,CAAA,UAAA,CAAA,CAAA;AACA,GAAA;AACA;AACA;AACA,EAAA,IAAA,OAAA,QAAA,CAAA,UAAA,KAAA,QAAA,KAAA,QAAA,CAAA,UAAA,GAAA,GAAA,IAAA,QAAA,CAAA,UAAA,IAAA,GAAA,CAAA,EAAA;AACA,IAAA,MAAA,IAAA,wBAAA,CAAA,QAAA,CAAA,UAAA,CAAA,CAAA;AACA,GAAA;AACA;AACA,EAAA,OAAA,QAAA,CAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA,MAAA,cAAA,SAAA,KAAA,CAAA;;AAGA,GAAA,WAAA,CAAA,UAAA,EAAA;AACA,IAAA,KAAA,CAAA,gBAAA,CAAA,CAAA;AACA,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AACA,GAAA;AACA,CAAA;AACA;AACA;AACA;AACA;AACA,MAAA,wBAAA,SAAA,KAAA,CAAA;AACA,GAAA,WAAA,CAAA,UAAA,EAAA;AACA,IAAA,KAAA,CAAA,CAAA,+BAAA,EAAA,UAAA,CAAA,CAAA,CAAA,CAAA;AACA,GAAA;AACA;;;;;;"}