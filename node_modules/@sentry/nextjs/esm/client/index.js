import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';
import { RewriteFrames } from '@sentry/integrations';
import { init as init$1, configureScope } from '@sentry/react';
export * from '@sentry/react';
export { Integrations } from '@sentry/react';
import { hasTracingEnabled, BrowserTracing, defaultRequestInstrumentationOptions } from '@sentry/tracing';
export { BrowserTracing } from '@sentry/tracing';
import { buildMetadata } from '../common/metadata.js';
import { addOrUpdateIntegration } from '../common/userIntegrations.js';
import { nextRouterInstrumentation } from './performance.js';
export { nextRouterInstrumentation } from './performance.js';
import { applyTunnelRouteOption } from './tunnelRoute.js';
export { captureUnderscoreErrorException } from '../common/_error.js';
export { withSentryServerSideGetInitialProps, wrapGetInitialPropsWithSentry } from './wrapGetInitialPropsWithSentry.js';
export { withSentryServerSideAppGetInitialProps, wrapAppGetInitialPropsWithSentry } from './wrapAppGetInitialPropsWithSentry.js';
export { withSentryServerSideDocumentGetInitialProps, wrapDocumentGetInitialPropsWithSentry } from './wrapDocumentGetInitialPropsWithSentry.js';
export { withSentryServerSideErrorGetInitialProps, wrapErrorGetInitialPropsWithSentry } from './wrapErrorGetInitialPropsWithSentry.js';

// Treeshakable guard to remove all code related to tracing

const globalWithInjectedValues = global

;

/** Inits the Sentry NextJS SDK on the browser with the React SDK. */
function init(options) {
  applyTunnelRouteOption(options);
  buildMetadata(options, ['nextjs', 'react']);
  options.environment = options.environment || process.env.NODE_ENV;
  addClientIntegrations(options);

  init$1(options);

  configureScope(scope => {
    scope.setTag('runtime', 'browser');
    const filterTransactions = event =>
      event.type === 'transaction' && event.transaction === '/404' ? null : event;
    filterTransactions.id = 'NextClient404Filter';
    scope.addEventProcessor(filterTransactions);
  });
}

function addClientIntegrations(options) {
  let integrations = options.integrations || [];

  // This value is injected at build time, based on the output directory specified in the build config. Though a default
  // is set there, we set it here as well, just in case something has gone wrong with the injection.
  const assetPrefixPath = globalWithInjectedValues.__rewriteFramesAssetPrefixPath__ || '';

  const defaultRewriteFramesIntegration = new RewriteFrames({
    // Turn `<origin>/<path>/_next/static/...` into `app:///_next/static/...`
    iteratee: frame => {
      try {
        const { origin } = new URL(frame.filename );
        frame.filename = _optionalChain([frame, 'access', _ => _.filename, 'optionalAccess', _2 => _2.replace, 'call', _3 => _3(origin, 'app://'), 'access', _4 => _4.replace, 'call', _5 => _5(assetPrefixPath, '')]);
      } catch (err) {
        // Filename wasn't a properly formed URL, so there's nothing we can do
      }

      return frame;
    },
  });
  integrations = addOrUpdateIntegration(defaultRewriteFramesIntegration, integrations);

  // This evaluates to true unless __SENTRY_TRACING__ is text-replaced with "false", in which case everything inside
  // will get treeshaken away
  if (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {
    if (hasTracingEnabled(options)) {
      const defaultBrowserTracingIntegration = new BrowserTracing({
        // eslint-disable-next-line deprecation/deprecation
        tracingOrigins: [...defaultRequestInstrumentationOptions.tracingOrigins, /^(api\/)/],
        routingInstrumentation: nextRouterInstrumentation,
      });

      integrations = addOrUpdateIntegration(defaultBrowserTracingIntegration, integrations, {
        'options.routingInstrumentation': nextRouterInstrumentation,
      });
    }
  }

  options.integrations = integrations;
}

export { init };
//# sourceMappingURL=index.js.map
