import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';
import { getHubFromCarrier, getMainCarrier } from '@sentry/core';
import { RewriteFrames } from '@sentry/integrations';
import { init as init$1, configureScope, getCurrentHub, Integrations } from '@sentry/node';
export * from '@sentry/node';
import { hasTracingEnabled } from '@sentry/tracing';
import { logger, escapeStringForRegex } from '@sentry/utils';
import * as domain$1 from 'domain';
import * as path from 'path';
import { buildMetadata } from '../common/metadata.js';
import { addOrUpdateIntegration } from '../common/userIntegrations.js';
import { isBuild } from './utils/isBuild.js';
export { captureUnderscoreErrorException } from '../common/_error.js';
export { ErrorBoundary, showReportDialog, withErrorBoundary } from '@sentry/react';
export { withSentryGetStaticProps, wrapGetStaticPropsWithSentry } from './wrapGetStaticPropsWithSentry.js';
export { withSentryServerSideGetInitialProps, wrapGetInitialPropsWithSentry } from './wrapGetInitialPropsWithSentry.js';
export { withSentryServerSideAppGetInitialProps, wrapAppGetInitialPropsWithSentry } from './wrapAppGetInitialPropsWithSentry.js';
export { withSentryServerSideDocumentGetInitialProps, wrapDocumentGetInitialPropsWithSentry } from './wrapDocumentGetInitialPropsWithSentry.js';
export { withSentryServerSideErrorGetInitialProps, wrapErrorGetInitialPropsWithSentry } from './wrapErrorGetInitialPropsWithSentry.js';
export { withSentryGetServerSideProps, wrapGetServerSidePropsWithSentry } from './wrapGetServerSidePropsWithSentry.js';
export { withSentry, withSentryAPI, wrapApiHandlerWithSentry } from './wrapApiHandlerWithSentry.js';

const globalWithInjectedValues = global

;

const domain = domain$1 ;

// TODO (v8): Remove this
/**
 * @deprecated This constant will be removed in the next major update.
 */
const IS_BUILD = isBuild();

const IS_VERCEL = !!process.env.VERCEL;

/** Inits the Sentry NextJS SDK on node. */
function init(options) {
  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && options.debug) {
    logger.enable();
  }

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Initializing SDK...');

  if (sdkAlreadyInitialized()) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('SDK already initialized');
    return;
  }

  buildMetadata(options, ['nextjs', 'node']);
  options.environment = options.environment || process.env.NODE_ENV;
  addServerIntegrations(options);
  // Right now we only capture frontend sessions for Next.js
  options.autoSessionTracking = false;

  // In an ideal world, this init function would be called before any requests are handled. That way, every domain we
  // use to wrap a request would inherit its scope and client from the global hub. In practice, however, handling the
  // first request is what causes us to initialize the SDK, as the init code is injected into `_app` and all API route
  // handlers, and those are only accessed in the course of handling a request. As a result, we're already in a domain
  // when `init` is called. In order to compensate for this and mimic the ideal world scenario, we stash the active
  // domain, run `init` as normal, and then restore the domain afterwards, copying over data from the main hub as if we
  // really were inheriting.
  const activeDomain = domain.active;
  domain.active = null;

  init$1(options);

  const filterTransactions = event => {
    return event.type === 'transaction' && event.transaction === '/404' ? null : event;
  };

  filterTransactions.id = 'NextServer404TransactionFilter';

  configureScope(scope => {
    scope.setTag('runtime', 'node');
    if (IS_VERCEL) {
      scope.setTag('vercel', true);
    }

    scope.addEventProcessor(filterTransactions);
  });

  if (activeDomain) {
    const globalHub = getHubFromCarrier(getMainCarrier());
    const domainHub = getHubFromCarrier(activeDomain);

    // apply the changes made by `nodeInit` to the domain's hub also
    domainHub.bindClient(globalHub.getClient());
    _optionalChain([domainHub, 'access', _ => _.getScope, 'call', _2 => _2(), 'optionalAccess', _3 => _3.update, 'call', _4 => _4(globalHub.getScope())]);
    // `scope.update()` doesnâ€™t copy over event processors, so we have to add it manually
    _optionalChain([domainHub, 'access', _5 => _5.getScope, 'call', _6 => _6(), 'optionalAccess', _7 => _7.addEventProcessor, 'call', _8 => _8(filterTransactions)]);

    // restore the domain hub as the current one
    domain.active = activeDomain;
  }

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('SDK successfully initialized');
}

function sdkAlreadyInitialized() {
  const hub = getCurrentHub();
  return !!hub.getClient();
}

function addServerIntegrations(options) {
  let integrations = options.integrations || [];

  // This value is injected at build time, based on the output directory specified in the build config. Though a default
  // is set there, we set it here as well, just in case something has gone wrong with the injection.
  const distDirName = globalWithInjectedValues.__rewriteFramesDistDir__ || '.next';
  // nextjs always puts the build directory at the project root level, which is also where you run `next start` from, so
  // we can read in the project directory from the currently running process
  const distDirAbsPath = path.resolve(process.cwd(), distDirName);
  const SOURCEMAP_FILENAME_REGEX = new RegExp(escapeStringForRegex(distDirAbsPath));

  const defaultRewriteFramesIntegration = new RewriteFrames({
    iteratee: frame => {
      frame.filename = _optionalChain([frame, 'access', _9 => _9.filename, 'optionalAccess', _10 => _10.replace, 'call', _11 => _11(SOURCEMAP_FILENAME_REGEX, 'app:///_next')]);
      return frame;
    },
  });
  integrations = addOrUpdateIntegration(defaultRewriteFramesIntegration, integrations);

  const defaultOnUncaughtExceptionIntegration = new Integrations.OnUncaughtException({
    exitEvenIfOtherHandlersAreRegistered: false,
  });
  defaultOnUncaughtExceptionIntegration.allowExclusionByUser = true;
  integrations = addOrUpdateIntegration(defaultOnUncaughtExceptionIntegration, integrations, {
    _options: { exitEvenIfOtherHandlersAreRegistered: false },
  });

  if (hasTracingEnabled(options)) {
    const defaultHttpTracingIntegration = new Integrations.Http({ tracing: true });
    integrations = addOrUpdateIntegration(defaultHttpTracingIntegration, integrations, {
      _tracing: {},
    });
  }

  options.integrations = integrations;
}

// TODO (v8): Remove this
/**
 * @deprecated This constant will be removed in the next major update.
 */
const deprecatedIsBuild = () => isBuild();

export { IS_BUILD, init, deprecatedIsBuild as isBuild };
//# sourceMappingURL=index.js.map
